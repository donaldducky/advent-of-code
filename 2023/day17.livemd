# Advent of Code 2023

```elixir
Mix.install([
  {:req, "~> 0.3.2"},
  {:libgraph, "~> 0.16.0"}
])
```

## Day 17

```elixir
input =
  "https://adventofcode.com/2023/day/17/input"
  |> Req.get!(headers: [cookie: "session=#{System.get_env("AOC_COOKIE")}"])
  |> Map.get(:body)
```

```elixir
sample = """
2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533
"""
```

## Section

```elixir
defmodule Day17 do
  def parse(input) do
    input
    |> String.split("\n", trim: true)
    |> grid()
  end

  def grid(lines) do
    rows = lines |> Enum.count()
    cols = lines |> hd() |> String.length()

    grid =
      for {row, y} <- Enum.with_index(lines),
          {c, x} <- String.split(row, "", trim: true) |> Enum.with_index(),
          into: %{},
          do: {{x, y}, String.to_integer(c)}

    %{
      rows: rows,
      cols: cols,
      data: grid
    }
  end

  def expand(pq, seen, grid) do
    {{:value, node}, pq} = PriorityQueue.pop(pq)
    # %{x: x, y: y, dir: {dir, n}} = node
    {cost, {x, y}, {dir, n}} = node

    [
      {turn_left(dir), 1},
      {turn_right(dir), 1}
    ]
    |> then(&if n < 3, do: [{dir, n + 1} | &1], else: &1)
    |> Enum.map(fn
      {:right, _} = dir -> {{x + 1, y}, dir}
      {:down, _} = dir -> {{x, y + 1}, dir}
      {:up, _} = dir ->  {{x, y - 1}, dir}
      {:left, _} = dir -> {{x - 1, y}, dir}
    end)
    # out of bounds check
    |> Enum.reject(&(!Map.has_key?(grid.data, elem(&1, 0))))
    |> Enum.reduce({pq, seen}, fn {coord, dir}, {pq, seen} ->
      new_cost = cost + grid.data[coord]
      node = {new_cost, coord, dir}
      if MapSet.member?(seen, {coord, dir}) do
        {pq, seen}
      else
        {
          PriorityQueue.push(pq, node, new_cost),
          MapSet.put(seen, {coord, dir})
        }
      end
    end)
  end

  def loss(grid, pos) do
    grid.data[pos]
  end

  def turn_left(dir) do
    %{left: :down, down: :right, right: :up, up: :left}[dir]
  end

  def turn_right(dir) do
    %{left: :up, down: :left, right: :down, up: :right}[dir]
  end

  def search(pq, dest, grid, seen) do
    Stream.iterate(1, &(&1 + 1))
    |> Enum.reduce_while({pq, seen}, fn _, {pq, seen} ->
      {:value, node} = PriorityQueue.peek(pq)
      {cost, coord, _} = node

      if coord == dest do
        {:halt, cost}
      else
        {:cont, expand(pq, seen, grid)}
      end
    end)
  end

  def part1(input) do
    grid = parse(input)
    pq = PriorityQueue.new()
    seen = MapSet.new()

    start = {0, 0}
    dest = {grid.cols - 1, grid.rows - 1}

    to_visit = [
      # {cost, {x, y}, direction}
      {0, start, {:right, 1}},
      {0, start, {:down, 1}}
    ]

    pq =
      to_visit
      |> Enum.reduce(pq, fn {cost, _coord, _dir} = node, pq ->
        PriorityQueue.push(pq, node, cost)
      end)

    search(pq, dest, grid, seen)
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Day17.part1(input)
```
